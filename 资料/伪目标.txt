伪目标就是一个不生成文件的目标
没有输出文件的目标通常被称为“伪目标”（phony targets）。伪目标通常用作辅助任务，例如清理编译生成的文件、准备环境等，因为这些目标不生成任何文件

如果我不标记伪目标,直接运行的时候,这个标签没有被依赖,一样不会被执行对

那如果我想不定义一个伪目标,但是在编译的时候每次都调用一个还不生成文件的清理方法,怎么实现呢?
可以在每个构建步骤中添加清理命令，而不必定义一个单独的伪目标。这可以确保在每次编译前执行清理操作。

下面是一个示例 Makefile，它在编译每个目标文件之前调用清理命令：

makefile
hello: main.o message.o
    gcc main.o message.o -o hello

main.o: main.c message.h
    -del main.o 2>nul
    gcc -c main.c

message.o: message.c message.h
    -del message.o 2>nul
    gcc -c message.c

在这个示例中，每次编译 main.o 和 message.o 之前，都会执行 del 命令来删除可能存在的旧的目标文件。这确保了每次编译都是干净的，不受旧文件的影响。

请注意这里使用了 -del，前面的 - 表示即使 del 命令失败（例如文件不存在），Make 也不会因为这个错误而停止。2>nul 用于将错误输出重定向到空设备，以避免显示错误消息。

默认情况下，Makefile 中的标签名（即目标）通常是文件名，因为 make 工具会假设这些目标是文件，并检查这些文件的时间戳以确定是否需要重新构建。但这并不是一个绝对的规则。您可以定义任何您希望的目标名称，只要这些目标符合您的构建需求。

如果一个目标标签没有指定任何依赖文件，make 工具会认为该目标始终是最新的。这意味着每次运行 make 时，该目标不会被重新构建，因为 make 认为它不需要更新。

即使将 all 作为伪目标（PHONY target）标记，它仍然会作为默认目标被优先执行。默认目标是 Makefile 中的第一个目标，无论它是否被标记为伪目标